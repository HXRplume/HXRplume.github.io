<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>蓝桥杯学习笔记 | 南星六月雪の空间</title><meta name="author" content="南星六月雪,hxr2510@mail.ustc.edu.cn"><meta name="copyright" content="南星六月雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编程练习题集锦    第一章 · 语言基础【1】小明和完美序列【题目描述】 小明又新学了一个概念，叫做完美序列。一个仅包含数字序列被称为完美序列，当且仅当数字序列中每个数字出现的次数等于这个数字。比如(1)，(2 2 3 3 3)。空序列也算。现在小明得到了一个数字序列，他想知道最少要删除多少个数字才能使得这个数字序列成为一个完美序列。 【输入输出描述】 输入格式：两行输入，第一行一个数字整数 n">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝桥杯学习笔记">
<meta property="og:url" content="https://example.com/2025/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="南星六月雪の空间">
<meta property="og:description" content="编程练习题集锦    第一章 · 语言基础【1】小明和完美序列【题目描述】 小明又新学了一个概念，叫做完美序列。一个仅包含数字序列被称为完美序列，当且仅当数字序列中每个数字出现的次数等于这个数字。比如(1)，(2 2 3 3 3)。空序列也算。现在小明得到了一个数字序列，他想知道最少要删除多少个数字才能使得这个数字序列成为一个完美序列。 【输入输出描述】 输入格式：两行输入，第一行一个数字整数 n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://example.com/image/top/top1.jpg">
<meta property="article:published_time" content="2025-01-27T02:43:03.000Z">
<meta property="article:modified_time" content="2025-03-04T14:51:34.566Z">
<meta property="article:author" content="南星六月雪">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/image/top/top1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "蓝桥杯学习笔记",
  "url": "https://example.com/2025/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://example.com/image/top/top1.jpg",
  "datePublished": "2025-01-27T02:43:03.000Z",
  "dateModified": "2025-03-04T14:51:34.566Z",
  "author": [
    {
      "@type": "Person",
      "name": "南星六月雪",
      "url": "https://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/tou.ico"><link rel="canonical" href="https://example.com/2025/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '蓝桥杯学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-square-binary"></i><span> 编程笔记</span></a></li><li><a class="site-page child" href="/categories/JavaSE%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-square-binary"></i><span> JavaSE学习教程</span></a></li><li><a class="site-page child" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-square-binary"></i><span> 课程笔记</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/top/top1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">南星六月雪の空间</span></a><a class="nav-page-title" href="/"><span class="site-name">蓝桥杯学习笔记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-square-binary"></i><span> 编程笔记</span></a></li><li><a class="site-page child" href="/categories/JavaSE%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"><i class="fa-fw fas fa-square-binary"></i><span> JavaSE学习教程</span></a></li><li><a class="site-page child" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-square-binary"></i><span> 课程笔记</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">蓝桥杯学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-27T02:43:03.000Z" title="发表于 2025-01-27 10:43:03">2025-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-04T14:51:34.566Z" title="更新于 2025-03-04 22:51:34">2025-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">编程笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 align = "center">编程练习题集锦</h1>  

<h2 id="第一章-·-语言基础"><a href="#第一章-·-语言基础" class="headerlink" title="第一章 · 语言基础"></a>第一章 · 语言基础</h2><h3 id="【1】小明和完美序列"><a href="#【1】小明和完美序列" class="headerlink" title="【1】小明和完美序列"></a>【1】小明和完美序列</h3><p>【题目描述】</p>
<p>小明又新学了一个概念，叫做完美序列。一个仅包含数字序列被称为完美序列，当且仅当数字序列中每个数字出现的次数等于这个数字。比如(1)，(2 2 3 3 3)。空序列也算。现在小明得到了一个数字序列，他想知道最少要删除多少个数字才能使得这个数字序列成为一个完美序列。</p>
<p>【输入输出描述】</p>
<p>输入格式：两行输入，第一行一个数字整数 <code>n</code>，表示数字序列中数字的个数。第二行包括 <code>n</code>  个整数，是数字序列中的具体数字。</p>
<p>输出格式：一行输出，表示最小要删除的数字个数。</p>
<p>【题解】</p>
<p>首先我们先要清楚如果计算最小要删除的数字个数：当某个数 <code>k</code>，输入个数为 <code>m</code> 时，不难发现，若是 <code>m</code>  大于等于 <code>k</code>，则需删除 <code>m-k</code> 个数；反之若是 <code>m</code> 小于 <code>k</code>，则需删除 <code>m</code> 个数。</p>
<p>明白这一点后，我们考虑如何记录下这个数字序列的信息。这里我们给出两种做法，分别是 1、使用复合结构，在记录下数字的同时记录下该数字出现的次数；2、使用数组存储数字，全部存储后一次遍历根据每个不同的数的出现次数来决定输出的多少。</p>
<p>先看第一种想法：我们想到在 <code>STL</code> 中的 <code>map</code> 具有存储一对数的功能，我们使用 <code>map&lt;int,int&gt;</code>，第一个数表示数字的大小，第二个数表示该数出现的次数。每当输入一个数 <code>x</code>，我们就使用 <code>mp[x]++</code> 将该数的出现次数自增。最终在输入结束后就同步记录下了数字和其出现次数。接着，根据之前的思路完成最小删除个数的计算即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(x, <span class="number">1</span>));</span><br><span class="line">            vc.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mp[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : vc)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[it] &lt; it)&#123;</span><br><span class="line">            ans += mp[it];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mp[it] &gt; it)&#123;</span><br><span class="line">            ans += mp[it] - it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种想法：我们可以仅用最简单的数据结构数组来记录所有输入的数字，接着需要使用排序函数将其从小到大排序，这样就方便了之后我们统计每个数字的出现次数。然后，我们遍历整个数组，使用 <code>count</code> 记录每个不同的数的出现次数。如果当前遍历到的数和数组中下一个数不一样，证明它是这种数中的最后一个，此时我们就可以按照上面的计算方式计算该数对最终结果的贡献次数，计算后将 <code>count</code> 赋零。如果它和数组中下一个数一样，那么我们就可以将 <code>count</code> 加 1，并继续遍历下一个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin &gt;&gt; num[i]; <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()); <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">int</span> number, i = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        number = num[i];</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (number != num[i<span class="number">+1</span>]) &#123;</span><br><span class="line">        res += count &gt;= number ? count - number : count;</span><br><span class="line">        count = <span class="number">0</span>; <span class="comment">// count归零</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【2】众数的最大数目"><a href="#【2】众数的最大数目" class="headerlink" title="【2】众数的最大数目"></a>【2】众数的最大数目</h3><p>【题目描述】</p>
<p>小蓝有一个长度为 <code>n</code> 的数组 <code>a</code>，现在对于每一个 <code>a[i]</code>，小蓝可以选择下面三种操作之一：</p>
<ul>
<li><code>a[i]=a[i-1]</code></li>
<li><code>a[i]=a[i+1]</code></li>
<li><code>a[i]=a[i]</code></li>
</ul>
<p>小蓝想知道她如果把每一个 <code>a[i]</code> 都操作之后，数组众数的数目最大是多少。</p>
<p>【输入输出描述】</p>
<p>输入格式：第一行输入一个整数，代表 <code>n</code>；第二行输入 <code>n</code> 个整数，代表 <code>a[1],a[2],a[3],...,a[n]</code> 。</p>
<p>输出格式：输出一行一个整数，代表众数的最大数目。</p>
<p>【题解】</p>
<p>本题我们采用逆向思维。题干中要求我们找出众数的最大数目，实际上就是要求我们找出一个数，它可以由最多的数经过操作之后得到。用这种想法，我们就可以使用一个 <code>map&lt;int, int&gt;</code> 容器来记录下每个数可以由几个数操作得到。例如：若输入一行整数为 <code>1,2,3</code>，则 <code>2</code> 可以由3个数操作得到。剩下的就只是简单的实现上述思想的过程，这里不再赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; nums[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		mp[nums[i]<span class="number">-1</span>]++; mp[nums[i]]++; mp[nums[i]<span class="number">+1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator m;</span><br><span class="line">	<span class="keyword">for</span> (m = mp.<span class="built_in">begin</span>(); m != mp.<span class="built_in">end</span>(); ++m) maxn = <span class="built_in">max</span>(maxn, m-&gt;second);</span><br><span class="line">	cout &lt;&lt; maxn &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h2 id="第二章-·-基础算法"><a href="#第二章-·-基础算法" class="headerlink" title="第二章 · 基础算法"></a>第二章 · 基础算法</h2><h3 id="【1】小蓝的漆房"><a href="#【1】小蓝的漆房" class="headerlink" title="【1】小蓝的漆房"></a>【1】小蓝的漆房</h3><p>【题目描述】</p>
<p>小蓝有一个漆房，其中有一条走廊需要油漆，走廊两旁有许多相邻的房子，每间房子最初被涂上一种颜色。现在希望将整个走廊涂成一种颜色，而小蓝每天只能涂一段长为 k 的区间。对于每个区间可以选择将其中的房子涂上任何一种颜色，或者保持原来的颜色不变。现在他想知道一共需要多少天才能将整个走廊涂好。</p>
<p>【输入输出描述】</p>
<p>输入格式：第一行包含一个整数 <code>t(1&lt;=t&lt;=100)</code>，表示测试用例的数量。每个测试用例的第一行包含两个整数 <code>n</code> 和 <code>k</code> ，第二行包含 <code>n</code> 个整数 <code>a[1], a[2], ..., a[n]</code>，分别表示每个房子最初的颜色。其中保证测试用例中 <code>n</code> 的总和不超过 10000。</p>
<p>输出格式：对于每个测试用例，输出一个整数，表示小蓝需要油漆的最少天数。</p>
<p>【题解】</p>
<p>本题使用基础算法中的枚举思想，其中最重要的一点是如何判断出最少的天数。我们可以考虑对每一种颜色进行枚举，假设当前枚举的颜色为 A。从走廊的一端开始，如果两旁的房子颜色为 A，那么不需要修改，继续判断下一个房子。如果两旁的房子颜色不是 A，那么需要修改，由于一次修改的区间范围固定，且在到此之前已经完成所有需要修改的部分，因此需要修改的天数加 1。最终，当到达走廊另一端时结束判断。用同样的方法将所有的颜色进行判断之后取其中需要天数最少的一种输出即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt; cin &gt;&gt; cnt;</span><br><span class="line">  <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">    <span class="type">int</span> number, len; cin &gt;&gt; number &gt;&gt; len;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">por</span><span class="params">(number)</span></span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; por[i];</span><br><span class="line">      s.<span class="built_in">insert</span>(por[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> min_day = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : s) &#123;</span><br><span class="line">      <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; number; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (por[j] == x) <span class="keyword">continue</span>;</span><br><span class="line">        day += <span class="number">1</span>;</span><br><span class="line">        j += len - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      min_day = <span class="built_in">min</span>(min_day, day);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; min_day &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【2】大石的搬运工"><a href="#【2】大石的搬运工" class="headerlink" title="【2】大石的搬运工"></a>【2】大石的搬运工</h3><p>【题目描述】</p>
<p>在一次游戏中，玩家需要操作一排 n 堆石头，进行 n-1 轮游戏。每一轮，玩家可以选择一堆石头，并将其移动到任意位置。在 n-1 轮移动结束时，要求将所有的石头移动到一起即为成功。移动的费用为石头的重量乘以移动的距离，例如：如果一堆重量为 2 的石头从位置 3 移动到位置 5，那么费用为 <code>2*(5-3)=4</code>。请计算出所有合法方案中，将所有石头移动到一起的最小费用。可能有多堆石头在同一个位置上，但是一轮只能选择移动其中一堆。</p>
<p>【输入输出描述】</p>
<p>输入格式：第一行一个整数 <code>n</code>，表示石头的数量。接下来 <code>n</code> 行，每行两个整数 <code>w[i]</code> 和 <code>p[i]</code>，分别表示第 <code>i</code> 堆石头的重量和初始位置。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure>
<p>输出格式：输出一个整数，表示最小的总移动费用。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>【题解】</p>
<p>在这个问题中，我们首先需要明确移动的费用总和与移动的顺序无关，因此只需要考虑最后的位置即可。接着我们需要分析如果放置石头才使费用总和最小。这里我们可以对于每堆石头，我们都计算它被移动到目标位置的费用，但由于数据范围较大，因此采用前缀和的思想。</p>
<p>我们可以先将所有石头按照位置排序，然后计算每个石头移动到任意位置的费用，再利用前缀和的思想将这些费用累加起来。具体地，我们可以定义两个数组 <code>pre[]</code> 和 <code>nex[]</code>，其中 <code>pre[i]</code> 表示前 <code>i</code> 个石头都移动到第 <code>i</code> 石头所在位置的总费用，<code>nex[i]</code> 表示第 <code>i</code> 个石头之后的所有石头都移动到第 <code>i</code> 个石头所在的位置的总费用。这样，对于石头，我们就可以在 <code>O(1)</code> 的时间内算出所有石头都移动到它的位置的总费用。</p>
<p>分析时间复杂度：排序算法时间复杂度为 <code>O(nlogn)</code>，计算 <code>pre</code> 和 <code>nex</code> 的时间复杂度为 <code>O(n)</code>，查找最小值的时间复杂度为 <code>O(n)</code>，所以总时间复杂度为 <code>O(nlogn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ll n; cin &gt;&gt; n;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; s[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; s[i].second &gt;&gt; s[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 前面的石头和</span></span><br><span class="line">    ll pre[n + <span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>];</span><br><span class="line">        pre[i] += wei * (s[i].first - s[i<span class="number">-1</span>].first);</span><br><span class="line">        wei += s[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后面的石头和</span></span><br><span class="line">    ll nex[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ll iew = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        nex[i] = nex[i + <span class="number">1</span>];</span><br><span class="line">        nex[i] += iew * (s[i<span class="number">+1</span>].first - s[i].first);</span><br><span class="line">        iew += s[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算总和</span></span><br><span class="line">    ll min_dis = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        min_dis = <span class="built_in">min</span>(min_dis, pre[i] + nex[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; min_dis;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【3】最大数组和"><a href="#【3】最大数组和" class="headerlink" title="【3】最大数组和"></a>【3】最大数组和</h3><p>【题目描述】</p>
<p>小明是一名勇敢的冒险家，现在他有一堆宝石。但是宝石会随着时间失去价值，因此他需要用规定次数对它们进行处理。他有两种处理方式：</p>
<ul>
<li>选出两个最小的宝石，并将它们从宝石组中删除。</li>
<li>选出最大的宝石，并将它从宝石组中删除</li>
</ul>
<p>现在，给你小明手上的宝石，请你告诉他在规定次数内，最大化宝石的总价值是多少。</p>
<p>【输入输出描述】</p>
<p>输入格式：第一行包含一个整数 <code>t</code>，表示数据组数。</p>
<p>对于每组数据，第一行包含两个整数 <code>n</code> 和 <code>k</code>，表示宝石的数量和规定的处理次数。</p>
<p>第二行包含 <code>n</code> 个整数 <code>a[1], a[2], ..., a[n]</code>，表示每个宝石的价值。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5 1</span><br><span class="line">2 5 1 10 6</span><br><span class="line">5 2</span><br><span class="line">2 5 1 10 6</span><br><span class="line">3 1</span><br><span class="line">1 2 3</span><br><span class="line">6 1</span><br><span class="line">15 22 12 10 13 11</span><br><span class="line">6 2</span><br><span class="line">15 22 12 10 13 11</span><br><span class="line">5 1</span><br><span class="line">999999996 999999999 999999997 999999998 999999995</span><br></pre></td></tr></table></figure>
<p>输出格式：对于每组数据，输出一个整数，表示在规定次数内，最大化宝石的总和。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">21</span><br><span class="line">11</span><br><span class="line">3</span><br><span class="line">62</span><br><span class="line">46</span><br><span class="line">3999999986</span><br></pre></td></tr></table></figure>
<p>【题解】</p>
<p>这道题目的题意具有一定迷惑性，我们需要仔细思考这个过程。我们总共需要处理 k 次，假如用贪心的想法，我们每次比较最小的两块宝石和与最大的宝石的价值，我们会发现对于如下情况：要求处理 2 次，数据为：10, 11, 14, 15, 22，我们会将 10, 11 以及 22 去除。但是实际上最好的处理方式是去除 15, 21 。因此这道题目不能用贪心的想法来解决。</p>
<p>我们应该对于这堆宝石升序排序后，对于规定次数 k 进行遍历，每次查看去除前 <code>2 * i</code> 个宝石和后 <code>k - i</code> 个宝石之后剩下的宝石价值。从中找出价值最高的一种方式。</p>
<p>而为了快速得到一定区间内的宝石价值之和，我们使用前缀和数组来存储数据。以上便是这道题目的思路和解法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N], prefix[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;t;y++) &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;<span class="comment">// 读取数组的长度 n 和选择的元素数量 k。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];<span class="comment">// 读取数组 a 的元素。</span></span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);<span class="comment">// 对数组 a 进行升序排序。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + a[i];&#125;<span class="comment">// 计算数组 a 的前缀和，存储在数组 prefix 中</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> cha = (prefix[n - (k-i)] - prefix[<span class="number">2</span> * i]);</span><br><span class="line">            <span class="comment">// 计算选择了 k-i 个最大元素后，去掉了 2*i 个最小元素的情况下的和。</span></span><br><span class="line">            <span class="comment">//中 i 表示已选择的最小元素的数量</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cha);</span><br><span class="line">            <span class="comment">// 更新 ans，保存当前的最大和。</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【4】商品储存管理"><a href="#【4】商品储存管理" class="headerlink" title="【4】商品储存管理"></a>【4】商品储存管理</h3><p>【题目描述】</p>
<p>现在在一个仓库中存有多种商品，这些商品根据类别和规格被有序地分类并编号，编号范围从 1 至 n。初始时，每种商品的库存量为 0。</p>
<p>现在管理团队设计了 m 个操作，每个操作涉及一个特定的商品区间，即一段连续的商品编号范围（例如区间 <code>[L, R]</code>）。执行这些操作时，区间内商品数量增加 1，然而，在某些情况下管理团队可能会决定不执行某些操作，使得这些操作涉及的商品区间内的库存量不会发生改变，维持原有的状态。</p>
<p>现在管理团队需要一个评估机制，用来确定如果某一个操作未被执行，那么最终会有多少种商品的库存量为 0。对此，请你为管理团队计算出，每个操作未执行时，库存量为 0 的商品的种类数。</p>
<p>【输入输出描述】</p>
<p><strong>输入格式：</strong>第一行包含两个整数 <code>n</code> 和 <code>m</code>，分别表示商品的种类数和操作个数。</p>
<p>接下来的 <code>m</code> 行，每行包含两个整数 <code>L</code> 和 <code>R</code>，表示一个操作设计的商品区间。</p>
<p><strong>输出格式：</strong>输出共 <code>m</code> 行，每行一个整数，第 i 行的整数表示如果不执行第 i 个操作，则最终库存量为 0 的商品种类数。</p>
<blockquote>
<p>对于所有评测用例：<code>1&lt;=n, m&lt;=3*10^5; 1&lt;=L&lt;=R&lt;=n</code>。</p>
</blockquote>
<p>【题解】</p>
<p> 这道题难点在于评测用例数据较大，因此不能单纯地使用差分数组记录下操作后，通过每次减少一个操作来解决。（例如如下方法就不可以）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 读入，数据不大用int</span></span><br><span class="line">  <span class="type">int</span> goods[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">operate</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> L, R; cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    operate[i] = <span class="built_in">make_pair</span>(L, R);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    goods[operate[i].first]++;</span><br><span class="line">    <span class="keyword">if</span> ((operate[i].second + <span class="number">1</span>) &lt;= n) goods[operate[i].second + <span class="number">1</span>]--; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    goods[operate[i].first]--;</span><br><span class="line">    <span class="keyword">if</span> ((operate[i].second + <span class="number">1</span>) &lt;= n) goods[operate[i].second + <span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      sum += goods[i];</span><br><span class="line">      <span class="keyword">if</span> (sum ==<span class="number">0</span>) num++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    sum = <span class="number">0</span>; num = <span class="number">0</span>;</span><br><span class="line">    goods[operate[i].first]++;</span><br><span class="line">    <span class="keyword">if</span> ((operate[i].second + <span class="number">1</span>) &lt;= n) goods[operate[i].second + <span class="number">1</span>]--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仔细思考会发现，这里的商品库存最小就是 0。如果减少一个操作后，该商品数量为 0，那么在减少操作之前该商品数量要么是 0，要么是 1，如果大于或等于 2，那么这个商品就决不可能通过减少一次操作使得库存量为 0。有了这样的想法，我们就可以通过差分数组还原出原数组，此时求出数量为 0 的商品个数。</p>
<p>同时，我们使用一个前缀和数组 <code>one[]</code> 维护在前 i 个商品中经过所有操作后商品数为 1 的个数。那么假设某个操作区间为 <code>[L, R]</code> ，减少该操作后，商品数为 0 的个数增加 <code>one[R] - one[L - 1]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n , m , zero , a[N] , l[N] , r[N] , one[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= m ; i ++)&#123; <span class="comment">//  差分数组记录操作</span></span><br><span class="line">        cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        a[l[i]] ++ , a[r[i] + <span class="number">1</span>] --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) a[i] += a[i - <span class="number">1</span>]; <span class="comment">// 恢复原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)&#123; <span class="comment">// 构造前缀和数组one[]，并统计商品数为 0 的个数</span></span><br><span class="line">        one[i] = one[i - <span class="number">1</span>] + (a[i] == <span class="number">1</span>);</span><br><span class="line">        zero += (a[i] == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算每次减少一个操作后商品数为 0 的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= m ; i ++) cout &lt;&lt; one[r[i]] - one[l[i] - <span class="number">1</span>] + zero &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【5】四个瓷瓶的神秘游戏"><a href="#【5】四个瓷瓶的神秘游戏" class="headerlink" title="【5】四个瓷瓶的神秘游戏"></a>【5】四个瓷瓶的神秘游戏</h3><p>【题目描述】</p>
<p>在一座寺庙中，有四个精美的瓷瓶，每个瓷瓶中都装有神秘的珍珠。珍珠的数量可以衡量寺庙的强大。寺庙的主持现在可以做出以下操作：</p>
<ul>
<li>选择一个瓷瓶，将其中的珍珠数量增加 2 个，同时将其它三个瓷瓶中的珍珠各减少 1 个。这个操作只有在其余三个瓷瓶中珍珠数量大于零时才能进行。</li>
</ul>
<p>主持的目标是使得四个瓷瓶中最多珍珠的数量尽可能大。请你计算通过如上操作，四个瓷瓶中最多珍珠的数量最大可以是多少。</p>
<p>【输入输出描述】</p>
<p><strong>输入格式：</strong>输入的第一行包含四个非负整数，分别代表四个瓷瓶中珍珠的初始数量，输入的四个整数的范围都在区间 <code>[0, 2*10^9]</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>输出格式：</strong>输出一行一个整数，表示主持通过操作后，四个瓷瓶中最多珍珠的数量最大可以是多少。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>【题解】</p>
<p>本题，我们首先给出基本想法：对于初始数量最多的瓷瓶每次操作增加2，其余瓷瓶每次操作减去1。直至最后，初始数量最少的瓷瓶中珍珠数量为0时结束操作。但显然这样不是最多的，此时我们可以将数量为0的瓷瓶进行一次操作使其数量增加2，其余瓷瓶数量减去1。再进行两次操作使其数量重新变为0，初始数量最多的瓷瓶增加4。在这一过程中，初始数量最多的瓷瓶内珍珠增加3，另外两个瓷瓶中珍珠减去3。</p>
<p>重复以上过程即可完成本题。但是最终数量第二少的瓷瓶中可能还剩余1颗珍珠或2颗珍珠。如果是一颗珍珠，此时再进行上述操作，初始数量最多的瓷瓶中珍珠数量会减少，因此不再进行操作。如果是两颗珍珠，此时再进行上述操作，初始数量最多的瓷瓶中珍珠数量可以增加1，因此可以进行操作。</p>
<p>但还有一种情况，如果四个瓷瓶中珍珠数量为 <code>a a a 0</code>形，那么经过尝试会发现最大珍珠数量为<code>2*a</code>，而不是通过我们上述操作得到的最大数量。</p>
<p>有了以上想法，我们就可以写出相应的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll num[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; num[<span class="number">0</span>] &gt;&gt; num[<span class="number">1</span>] &gt;&gt; num[<span class="number">2</span>] &gt;&gt; num[<span class="number">3</span>];</span><br><span class="line">  <span class="built_in">sort</span>(num, num + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; num[<span class="number">1</span>] == num[<span class="number">2</span>] &amp;&amp; num[<span class="number">2</span>] == num[<span class="number">3</span>]) &#123;</span><br><span class="line">      cout &lt;&lt; num[<span class="number">3</span>] * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    num[<span class="number">3</span>] += <span class="number">2</span> * num[<span class="number">0</span>];</span><br><span class="line">    num[<span class="number">1</span>] -= num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (num[<span class="number">1</span>] % <span class="number">3</span> != <span class="number">2</span>) cout &lt;&lt; num[<span class="number">3</span>] + num[<span class="number">1</span>] / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; num[<span class="number">3</span>] + num[<span class="number">1</span>] / <span class="number">3</span> * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h2 id="第三章-·-搜索"><a href="#第三章-·-搜索" class="headerlink" title="第三章 · 搜索"></a>第三章 · 搜索</h2><h3 id="【1】特殊的多边形"><a href="#【1】特殊的多边形" class="headerlink" title="【1】特殊的多边形"></a>【1】特殊的多边形</h3><p>【题目描述】</p>
<p>假设一个 n 边形 n 条边为 <code>a1,a2,a3,...,an</code>，定义该 n 边形的值 <code>v=a1*a2*a3*...*an</code>。定义两个 n 边形不同是指至少有一边的长度在一个 n 边形中有使用而另一个 n 边形没有用到，如 <code>(3,4,5,6)</code> 和 <code>(3,5,4,6)</code> 是两个相同的 n 边形，<code>(3,4,5,6)</code> 和 <code>(4,5,6,7)</code> 是两个不同的 n 边形。</p>
<p>现在有 <code>t</code> 和 <code>n</code> ，表示 t 个询问并且询问的是 n 边形，每个询问给定一个区间 <code>[l,r]</code>，问有多少个 n 边形的值（要求所有边长度各不相同）在该区间范围内。</p>
<p>【输入输出描述】</p>
<p><strong>输入格式：</strong>第一行包含两个正整数 <code>t,n</code>，表示有 t 个询问，询问的是 n 边形。接下来 t 行，每行有两个空格隔开的正整数 <code>l, r</code> ，表示询问区间 <code>[l, r]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">30</span> <span class="number">50</span></span><br><span class="line"><span class="number">60</span> <span class="number">200</span></span><br><span class="line"><span class="number">200</span> <span class="number">400</span></span><br></pre></td></tr></table></figure>
<p><strong>输出格式：</strong>输出共 t 行，第 i 行对应第 i 个查询的 n 边形个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于所有评测用例：<code>1&lt;=t&lt;=1e5, 3&lt;=n&lt;=10, 1&lt;=l&lt;=r&lt;=1e5</code>。</p>
</blockquote>
<p>【题解】</p>
<p>本题我们采用搜索算法并使用剪枝优化。首先，由于有多次查询，我们不妨将所有乘积可能的情况都计算出来，从而方便最后的询问。由此，我们的搜索过程便是对于乘积进行搜索，而利用 DFS，我们得到的 n 元组是递增的，每一次搜索可以计算当前这个位置的上限，并记录当前所有边的乘积，因为乘的越多数字越大，当乘积大于 <code>1e5</code> 时直接返回。同时记录以下 <code>n-1</code> 条边的长度和 <code>sum</code>，最后一条边必须小于 <code>sum</code>。最后用前缀和快速求和查询。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 查找的是n边形</span></span><br><span class="line"><span class="type">int</span> cnt[N], prefix[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> dep, <span class="type">int</span> st, <span class="type">int</span> mul, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mul &gt; <span class="number">1e5</span>) <span class="keyword">return</span>; <span class="comment">// 剪枝1：边乘积不大于1e5</span></span><br><span class="line">    <span class="keyword">if</span> (dep == n + <span class="number">1</span>) &#123;</span><br><span class="line">        cnt[mul] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> up = <span class="built_in">pow</span>(<span class="number">1e5</span> / mul, <span class="number">1.0</span> / (n + <span class="number">1</span> - dep)) + <span class="number">1</span>; <span class="comment">// 剪枝2：在对应乘积要求下下一条边的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = st + <span class="number">1</span>; i &lt; (dep == n ? <span class="built_in">min</span>(sum, up) : up); i++) &#123;</span><br><span class="line">        <span class="built_in">DFS</span>(dep + <span class="number">1</span>, i, mul * i, sum + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t &gt;&gt; n;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e5</span>; i++) prefix[i] = prefix[i - <span class="number">1</span>] + cnt[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; prefix[r] - prefix[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【2】串变换"><a href="#【2】串变换" class="headerlink" title="【2】串变换"></a>【2】串变换</h3><p>【题目描述】</p>
<p>有两个长度为 n 的数字字符串 S 和 T。一共有 k 个操作，操作只可能是以下两种类型：</p>
<ul>
<li><code>1  x  v</code> 表示将 <code>S[x]</code> 变为 <code>(S[x] + v) % 10</code>；</li>
<li><code>2  x  y</code> 表示交换 <code>S[x]</code> 和 <code>S[y]</code>。</li>
</ul>
<p>你可以挑选出任意个操作，以任意顺序执行，但是每个操作最多只能执行一次，如果可以将 S 串变为 T 串，则输出 <code>Yes</code>，反之输出 <code>No</code>。</p>
<p>【输入输出描述】</p>
<p><strong>输入格式：</strong>第一行输入一个正整数 n，表示字符串 S 和 T 的长度。第二行输入一个长度为 n 只由数字构成的字符串 S。第三行输入一个长度为 n 只由数字构成的字符串 T。第四行输入一个正整数 k，表示操作的数量。接下来 k 行，每行三个整数，其中第 i 行表示第 i 种操作的三个参数 <code>op[i], x[i], y[i]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">01012</span></span><br><span class="line"><span class="number">10103</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>输出格式：</strong>一行一个字符串，如果通过操作可以使 S 串和 T 串相等，则输出 <code>Yes</code>，反之则输出 <code>No</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于所有评测用例：<code>1&lt;=n&lt;=10, 1&lt;=k&lt;=7, 1&lt;=op[i]&lt;=2, 0&lt;=x[i],y[i]&lt;n</code>。</p>
</blockquote>
<p>【题解】</p>
<p>这道题目，我们不难想到<strong>全排列</strong>是一种解决方法。因为，第一种方法就是直接使用全排列函数，遍历所有可能的操作方法，如果找到一种成立方案则返回 <code>Yes</code>，反之返回 <code>No</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s, t;</span><br><span class="line"><span class="type">int</span> n, k, ans;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        cin &gt;&gt; v[i][<span class="number">0</span>] &gt;&gt; v[i][<span class="number">1</span>] &gt;&gt; v[i][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        string s1 = s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> temp = s1[v[i][<span class="number">1</span>]] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                temp = (temp + v[i][<span class="number">2</span>]) % <span class="number">10</span>;</span><br><span class="line">                s1[v[i][<span class="number">1</span>]] = <span class="built_in">char</span>(temp + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">swap</span>(s1[v[i][<span class="number">1</span>]], s1[v[i][<span class="number">2</span>]]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s1 == t) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>()));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 另一种方法其实就是将全排列的思想用到 DFS 中，即利用递归过程实现全排列。每一次完成一种操作后递归选择下一个操作，直至实现最终效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;  <span class="comment">//记录三个数据类型</span></span><br><span class="line">  <span class="type">int</span> ops, x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">postion</span><span class="params">(<span class="type">int</span> &amp;id, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, string s)</span> </span>&#123;  <span class="comment">//执行修改，返回修改完成后的串</span></span><br><span class="line">  <span class="keyword">if</span> (id == <span class="number">1</span>) s[x] = (s[x] - <span class="string">&#x27;0&#x27;</span> + y) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">swap</span>(s[x], s[y]);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>];  <span class="comment">//状态数组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;Data&gt;&amp; arr, string s1, string &amp;s2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//每一次询问，如果相等则立即返回</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;   <span class="comment">//参考全排列，枚举每一个，拿第一个没有使用过的状态</span></span><br><span class="line">      <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; <span class="comment">//跳过使用过的状态</span></span><br><span class="line">      vis[i] = <span class="literal">true</span>;   <span class="comment">//标记为使用</span></span><br><span class="line">      string temp = s1;  <span class="comment">//记录开始时s1的串</span></span><br><span class="line">      s1 = <span class="built_in">postion</span>(arr[i].ops, arr[i].x, arr[i].y, s1);  <span class="comment">//执行对s1的修改</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span>(arr, s1, s2)) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//递归过程，如果找到则快速返回</span></span><br><span class="line">      vis[i] = <span class="literal">false</span>;   <span class="comment">//回溯过程，标记为未使用</span></span><br><span class="line">      s1 = temp;  <span class="comment">//将s1变成原来的串</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">  string s1, s2;</span><br><span class="line">  cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">  <span class="keyword">if</span> (s1 == s2) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line">  <span class="function">vector&lt;Data&gt; <span class="title">arr</span><span class="params">(k)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">      cin &gt;&gt; arr[i].ops &gt;&gt; arr[i].x &gt;&gt; arr[i].y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">dfs</span>(arr, s1, s2)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【3】团建"><a href="#【3】团建" class="headerlink" title="【3】团建"></a>【3】团建</h3><p>【题目描述】</p>
<p>小蓝和小光在玩一个游戏，两个分别拿到一棵大小为 n 和 m 的树，树上的每一个结点上面都有一个正整数权值。两人需要从各自树上的根结点出发走向某个叶结点，这会形成一个正整数序列，两人的最长公共前缀即为他们的得分。给出两棵树，请计算两个人最多的得分是多少？</p>
<p>【输入输出格式】</p>
<p><strong>输入格式：</strong> 输入的第一行包含两个正整数 n, m，用一个空格分隔。</p>
<p>第二行包含 n 个正整数，相邻整数之间用一个空格分隔，其中 <code>c[i]</code> 表示第一棵树结点 i 上的权值。</p>
<p>第三行包含 m 个正整数，相邻整数之间用一个空格分隔，其中 <code>d[i]</code> 表示第二棵树结点 i 上的权值。</p>
<p>接下来 n-1 行，每行包含两个正整数 <code>u</code> ，<code>v</code>，表示第一棵树中包含一条 <code>u</code> 和 <code>v</code> 之间的边。</p>
<p>接下来 m-1 行，每行包含两个正整数 <code>u</code> ，<code>v</code>，表示第二棵树中包含一条 <code>u</code> 和 <code>v</code> 之间的边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span></span><br><span class="line"><span class="number">10</span> <span class="number">40</span> <span class="number">20</span> <span class="number">30</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出格式：</strong> 输出一行包含一个整数表示答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>【题解】</p>
<p>这同样也是一道搜索问题，但特殊之处在于它需要同时对两棵树进行搜索，这样才能使时间利用最大化。也就是说，我们从根结点开始，依次搜索两棵树相应的结点。如果这两个结点权值相同，我们就可以认为到目前为止两棵树搜索结果的前缀相同，可以继续搜索；否则，两棵树的搜索结果前缀已经出现不同，应该停止当前搜索过程。最终记录前缀最长的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> n, m, res, a[N], b[N];  </span><br><span class="line"><span class="comment">// n 和 m 分别表示两个图的节点数，res 用于存储最大匹配深度，</span></span><br><span class="line"><span class="comment">// a 和 b 分别存储两个图的节点标记</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G1[N], G2[N];   <span class="comment">// G1 和 G2 分别存储两个图的邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索函数</span></span><br><span class="line"><span class="comment">// 因为是树，不用考虑除父结点之外的回溯情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u1, <span class="type">int</span> far1, <span class="type">int</span> u2, <span class="type">int</span> far2, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">    res = <span class="built_in">max</span>(res, dep);  <span class="comment">// 更新最大匹配深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用哈希表存储第一个图中当前节点的邻接节点及其标记</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u1]) &#123;  <span class="comment">// 遍历第一个图中当前节点 u1 的邻接节点</span></span><br><span class="line">        <span class="keyword">if</span> (v == far1) <span class="keyword">continue</span>;  <span class="comment">// 跳过父节点（避免回溯）</span></span><br><span class="line">        mp[a[v]] = v;  <span class="comment">// 将邻接节点的标记存储到哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历第二个图中当前节点 u2 的邻接节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u2]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == far2) <span class="keyword">continue</span>;  <span class="comment">// 跳过父节点（避免回溯）</span></span><br><span class="line">        <span class="comment">// 如果第二个图的邻接节点标记在第一个图的哈希表中存在</span></span><br><span class="line">        <span class="keyword">if</span> (mp[b[v]]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(mp[b[v]], u1, v, u2, dep + <span class="number">1</span>);  <span class="comment">// 递归搜索，深度加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  <span class="comment">// 输入两个图的节点数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];  <span class="comment">// 输入第一个图的节点标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; b[i];  <span class="comment">// 输入第二个图的节点标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入第一个图的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G1[u].<span class="built_in">push_back</span>(v);  <span class="comment">// 添加边</span></span><br><span class="line">        G1[v].<span class="built_in">push_back</span>(u);  <span class="comment">// 添加边（无向图）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入第二个图的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G2[u].<span class="built_in">push_back</span>(v);  <span class="comment">// 添加边</span></span><br><span class="line">        G2[v].<span class="built_in">push_back</span>(u);  <span class="comment">// 添加边（无向图）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个图的根节点标记不匹配，直接输出 0</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) <span class="keyword">return</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从根节点开始深度优先搜索，初始深度为 1</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最大匹配深度</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h2 id="第四章-·-动态规划"><a href="#第四章-·-动态规划" class="headerlink" title="第四章 · 动态规划"></a>第四章 · 动态规划</h2><div STYLE="page-break-after: always;"></div>

<h2 id="第五章-·-字符串"><a href="#第五章-·-字符串" class="headerlink" title="第五章 · 字符串"></a>第五章 · 字符串</h2><h3 id="【1】诗歌双联"><a href="#【1】诗歌双联" class="headerlink" title="【1】诗歌双联"></a>【1】诗歌双联</h3><p>【题目描述】</p>
<p>小桥准备了两个字符串<code>s</code>和<code>t</code>。她发现，如果从字符串<code>s</code>中选出两个长度为<code>k</code>的不相交字串，并将它们拼接在一起（不能改变相对位置），可能会形成一个包含<code>t</code>的字符串。为了验证这个想法，她想设计一种算法来检验是否可以这样做。</p>
<p>【输入输出描述】</p>
<p><strong>输入格式：</strong>第一行包含三个整数<code>n,m,k (2&lt;=m&lt;=2*k&lt;=n&lt;=1e2)</code>，表示字符串<code>s</code>和字符串<code>t</code>的长度，以及可选子串的长度。接下来两行是由小写字母组成的字符串<code>s</code>和<code>t</code>。</p>
<p><strong>输出格式：</strong>如果可以选出两个字串，使得拼接后得到的字符串包含<code>t</code>，则输出<code>Yes</code>，否则输出<code>No</code>。</p>
<p>【题解】</p>
<p>本题，我们使用<strong>KMP</strong>算法。我们通过遍历所有可能组成的字符串，并依次使用<strong>KMP</strong>判断是否含有要求的子串来解决这个问题。</p>
<p>在此过程中，有两个难点，一是如何将所有的可能组成的子串不遗漏地遍历，另一个是完成<strong>KMP</strong>算法。具体实现方式我们依次分析：</p>
<p>为了不遗漏地遍历所有子串，我们可以使用C++中自带的<code>substr()</code>方法将所有可能的长度为<code>k</code>的子串存入容器中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; f;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">	f.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, k)); <span class="comment">// 其中i表示子串开始的位置，k表示子串的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于两个子串不能有重复的元素，我们使用嵌套<code>for</code>循环依次拼接两个可能的子串，并用<code>valid</code>记录是否出现正确的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = f.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i + k; j &lt; len; ++j) &#123;</span><br><span class="line">		string x = f[i] + f[j]; <span class="comment">// 拼接字符串</span></span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">kmp</span>(x,t)) &#123;</span><br><span class="line">			valid = <span class="literal">true</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着继续分析如何实现<strong>KMP</strong>算法，这主要是一个记住并使用模板的过程，在此不再赘述其具体细节。（可以参考以下网站：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Higurashi-kagome/p/18013626）">https://www.cnblogs.com/Higurashi-kagome/p/18013626）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123; <span class="comment">// 构建next数组</span></span><br><span class="line">		<span class="keyword">while</span> (idx &amp;&amp; t[i] != t[idx]) &#123;</span><br><span class="line">			idx = next[idx - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == t[idx]) &#123;</span><br><span class="line">			idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 匹配模式串和主串</span></span><br><span class="line">		<span class="keyword">while</span> (idx &amp;&amp; s[i] != t[idx]) &#123;</span><br><span class="line">			idx = next[idx - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[idx]) &#123;</span><br><span class="line">			idx++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;	 </span><br></pre></td></tr></table></figure>
<p>综合上述过程就完成了这道题，总体而言思路比较清晰，可以认为是一个不错的模板题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kmp</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx &amp;&amp; t[i] != t[idx]) &#123;</span><br><span class="line">            idx = next[idx - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == t[idx]) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx &amp;&amp; s[i] != t[idx]) &#123;</span><br><span class="line">            idx = next[idx - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[idx] == s[i]) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;string&gt; f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span> - k; ++i) &#123;</span><br><span class="line">        f.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = f.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + k; j &lt; len; ++j) &#123;</span><br><span class="line">            string x = f[i] + f[j];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">kmp</span>(x,t)) &#123;</span><br><span class="line">                valid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valid) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h2 id="第六章-·-数学"><a href="#第六章-·-数学" class="headerlink" title="第六章 · 数学"></a>第六章 · 数学</h2><div STYLE="page-break-after: always;"></div>

<h2 id="第七章-·-数据结构"><a href="#第七章-·-数据结构" class="headerlink" title="第七章 · 数据结构"></a>第七章 · 数据结构</h2><div STYLE="page-break-after: always;"></div>

<h2 id="第八章-·-图论"><a href="#第八章-·-图论" class="headerlink" title="第八章 · 图论"></a>第八章 · 图论</h2><h3 id="【1】寻找图中是否存在路径"><a href="#【1】寻找图中是否存在路径" class="headerlink" title="【1】寻找图中是否存在路径"></a>【1】寻找图中是否存在路径</h3><p>【题目描述】</p>
<p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong> 图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含 <code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [ui, vi]</code> 表示顶点 <code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由 <strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p>
<p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点 <code>destination</code> 结束的 <strong>有效路径</strong> 。</p>
<p>给你数组 <code>edges</code> 和整数 <code>n</code>、<code>source</code> 和 <code>destination</code>，如果从 <code>source</code> 到 <code>destination</code> 存在 <strong>有效路径</strong> ，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>
<p>【输入输出描述】</p>
<p>输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5</p>
<p>输出：false</p>
<p>解释：不存在由顶点 0 到顶点 5 的路径.</p>
<div style="text-align: center;"><img src="/image/8.1.png" alt="示例图片" width="50%"></div>

<p>【题解】</p>
<p>这是一个经典的判断图中两点连通性的问题。我们在这里采用广度优先搜索和深度优先搜素两种方法进行解答。</p>
<p>1、广度优先搜索</p>
<p>使用广度优先搜索判断顶点 source 到顶点 destination 的连通性，需要我们从顶点 source 开始按照层次依次遍历每一层的顶点，检测是否可以到达顶点 destination。遍历过程我们使用队列存储最近访问过的顶点，同时记录每个顶点的访问状态，每次从队列中取出顶点 vertex 时，将其未访问过的邻接顶点入队列。</p>
<p>初始时将顶点 source 设为已访问，并将其入队列。每次将队列中的节点 vertex 出队列，并将与 vertex 相邻且未访问的顶点 next 入队列，并将 next 设为已访问。当队列为空或访问到顶点 destination 时遍历结束，返回顶点 destination 的访问状态即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPath</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n); <span class="comment">// 构造邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = edge[<span class="number">0</span>], y = edge[<span class="number">1</span>];</span><br><span class="line">            adj[x].<span class="built_in">emplace_back</span>(y); <span class="comment">// 在vector容器中使用emplace_back()比push_back()更高效</span></span><br><span class="line">            adj[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(source); <span class="comment">// 在队列中只能使用emplace这种添加方法</span></span><br><span class="line">        visited[source] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> vertex = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (vertex == destination) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : adj[vertex]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[next]) &#123;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(next);</span><br><span class="line">                    visited[next] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[destination];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2、深度优先搜索</p>
<p>我们使用深度优先搜索检测顶点 source,destination 的连通性，需要从顶点 source 开始依次遍历每一条可能的路径，判断可以到达顶点 destination，同时还需要记录每个顶点的访问状态防止重复访问。</p>
<p>首先从顶点 source 开始遍历并进行递归搜索。搜索时每次访问一个顶点 vertex 时，如果 vertex 等于 destination 则直接返回，否则将该顶点设为已访问，并递归访问与 vertex 相邻且未访问的顶点 next。如果通过 next 的路径可以访问到 destination，此时直接返回 true，当访问完所有的邻接节点仍然没有访问到 destination，此时返回 false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;adj, vector&lt;<span class="type">bool</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == destination) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[source] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : adj[source]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[next] &amp;&amp; <span class="built_in">dfs</span>(next, destination, adj, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPath</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = edge[<span class="number">0</span>], y = edge[<span class="number">1</span>];</span><br><span class="line">            adj[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">            adj[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(source, destination, adj, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="【2】所有可能的路径"><a href="#【2】所有可能的路径" class="headerlink" title="【2】所有可能的路径"></a>【2】所有可能的路径</h3><p>【题目描述】</p>
<p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<p>【输入输出描述】</p>
<p>输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]</p>
<p>输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</p>
<div style="text-align: center;"><img src="/image/8.2.png" alt="示例图片" width="50%"></div>

<p>【题解】</p>
<p>本题和上题相比，差别在于需要输出所有可能的路径，因此我们需要使用一个容器来记录所有的路径，按照要求，我们使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans; <span class="comment">// 记录所有的路径集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 记录每一条路径</span></span><br></pre></td></tr></table></figure>
<p>之后，我们主要使用深度优先搜索完成本题，这种写法主要针对的就是输出路径的搜索方式。其中，path需要用到回溯的思想，从而在深度搜索的同时，可以回到之前未走过的路径上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == n) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : graph[x]) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">DFS</span>(graph, i, n);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">DFS</span>(graph, <span class="number">0</span>, graph.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="【3】统计无向图中无法互相到达点对数"><a href="#【3】统计无向图中无法互相到达点对数" class="headerlink" title="【3】统计无向图中无法互相到达点对数"></a>【3】统计无向图中无法互相到达点对数</h3><p>【题目描述】</p>
<p>给你一个整数 <code>n</code> ，表示一张 <strong>无向图</strong> 中有 <code>n</code> 个节点，编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>无向</strong> 边。</p>
<p>请你返回 <strong>无法互相到达</strong> 的不同 <strong>点对数目</strong> 。</p>
<p>【输入输出描述】</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]</span><br><span class="line">输出：14</span><br><span class="line">解释：总共有 14 个点对互相无法到达：</span><br><span class="line">[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]</span><br><span class="line">所以我们返回 14 。</span><br></pre></td></tr></table></figure>
<div style="text-align: center;"><img src="/image/8.3.png" alt="示例图片" width="50%"></div>

<p>【题解】</p>
<p>本题首先需要明白如何计算无法互相到达的不同点对数目。假设存在一个连通片的顶点数量为 x，总共有 n 个顶点，则这个连通片总共贡献了 <code>x*(n-x)</code> 个无法互相到达的不同点对数目。依照上面的方法统计所有的连通片，此时，每个点对都统计了两次，因此最终结果还需要除以 2。</p>
<p>接下来我们思考如何遍历所有的连通片。我们采用深度优先遍历，每一次遍历都只可能遍历其中一个连通片，我们的目标就是统计这个连通片中顶点的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x)</span> </span>&#123; <span class="comment">// 从x开始深度遍历</span></span><br><span class="line">        visited[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : graph[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[y]) &#123;</span><br><span class="line">                cnt += <span class="built_in">DFS</span>(graph, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges) &#123; <span class="comment">// 创建邻接表</span></span><br><span class="line">            graph[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            graph[edge[<span class="number">1</span>]].<span class="built_in">push_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 创建标记表</span></span><br><span class="line">            visited.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 统计每个连通片的贡献次数</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> cnt = <span class="built_in">DFS</span>(graph, i);</span><br><span class="line">                ans += cnt * (n - cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div STYLE="page-break-after: always;"></div>

<h2 id="第九章-·-计算几何"><a href="#第九章-·-计算几何" class="headerlink" title="第九章 · 计算几何"></a>第九章 · 计算几何</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://example.com">南星六月雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://example.com/2025/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://example.com/2025/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://example.com" target="_blank">南星六月雪の空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post-share"><div class="social-share" data-image="/image/top/top1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/01/29/Java%E6%A6%82%E8%BF%B0/" title="Java概述"><img class="cover" src="/image/top/top2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java概述</div></div><div class="info-2"><div class="info-item-1">Java概述     【本文概述】作为第一篇文章，我们简要了解一下 Java 的历史和相应的特点。同时，我们要理解 Java 的运行机制，下载安装 JDK，为未来的学习做准备。最后，完成 Hello World 程序并成功编译执行，理解 Java 的执行流程。  1.1 Java 的诞生这部分内容对于我们学习而言并不是非常重要，在这里仅提供一张图片简单展示 Java 的发展历程。   到目前为止，Java 技术体系主要以下几个版本，分别是 Java SE 标准版、Java EE 企业版、Java ME 小型版。 1.2 Java 的重要特点1）Java 语言是面向对象的 (oop)。 2）Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集是 Java 程序的重要保证。 3）Java 语言是跨平台性的。【即：一个已经过编译的 .class 文件可以在多个不同的系统下运行】   4）Java 语言是解释性的。目前的编程语言可分为解释型语言和编译型语言。两者的区别是解释型语言编译后得到的代码不能直接被机器执行，需要解释器来执行，例如...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">南星六月雪</div><div class="author-info-description">我亦蝇营客, 偶来人世间</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个永远在路上的旅人！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">编程练习题集锦</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%C2%B7-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-text">第一章 · 语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%B0%8F%E6%98%8E%E5%92%8C%E5%AE%8C%E7%BE%8E%E5%BA%8F%E5%88%97"><span class="toc-text">【1】小明和完美序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%902%E3%80%91%E4%BC%97%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE"><span class="toc-text">【2】众数的最大数目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%C2%B7-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-text">第二章 · 基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%B0%8F%E8%93%9D%E7%9A%84%E6%BC%86%E6%88%BF"><span class="toc-text">【1】小蓝的漆房</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%902%E3%80%91%E5%A4%A7%E7%9F%B3%E7%9A%84%E6%90%AC%E8%BF%90%E5%B7%A5"><span class="toc-text">【2】大石的搬运工</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%903%E3%80%91%E6%9C%80%E5%A4%A7%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">【3】最大数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%904%E3%80%91%E5%95%86%E5%93%81%E5%82%A8%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">【4】商品储存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%905%E3%80%91%E5%9B%9B%E4%B8%AA%E7%93%B7%E7%93%B6%E7%9A%84%E7%A5%9E%E7%A7%98%E6%B8%B8%E6%88%8F"><span class="toc-text">【5】四个瓷瓶的神秘游戏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%C2%B7-%E6%90%9C%E7%B4%A2"><span class="toc-text">第三章 · 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%901%E3%80%91%E7%89%B9%E6%AE%8A%E7%9A%84%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-text">【1】特殊的多边形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%902%E3%80%91%E4%B8%B2%E5%8F%98%E6%8D%A2"><span class="toc-text">【2】串变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%903%E3%80%91%E5%9B%A2%E5%BB%BA"><span class="toc-text">【3】团建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%C2%B7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">第四章 · 动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%C2%B7-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">第五章 · 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%901%E3%80%91%E8%AF%97%E6%AD%8C%E5%8F%8C%E8%81%94"><span class="toc-text">【1】诗歌双联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%C2%B7-%E6%95%B0%E5%AD%A6"><span class="toc-text">第六章 · 数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%C2%B7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">第七章 · 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%C2%B7-%E5%9B%BE%E8%AE%BA"><span class="toc-text">第八章 · 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%901%E3%80%91%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84"><span class="toc-text">【1】寻找图中是否存在路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%902%E3%80%91%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">【2】所有可能的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%903%E3%80%91%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0"><span class="toc-text">【3】统计无向图中无法互相到达点对数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%C2%B7-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="toc-text">第九章 · 计算几何</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="操作系统原理与设计（一）操作系统概述">操作系统原理与设计（一）操作系统概述</a><time datetime="2025-03-09T15:18:14.000Z" title="发表于 2025-03-09 23:18:14">2025-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/20/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/" title="Java的基本程序设计（2）"><img src="/image/top/top4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java的基本程序设计（2）"/></a><div class="content"><a class="title" href="/2025/02/20/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/" title="Java的基本程序设计（2）">Java的基本程序设计（2）</a><time datetime="2025-02-20T09:47:44.000Z" title="发表于 2025-02-20 17:47:44">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/17/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/" title="Java的基本程序设计（1）"><img src="/image/top/top3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java的基本程序设计（1）"/></a><div class="content"><a class="title" href="/2025/02/17/Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/" title="Java的基本程序设计（1）">Java的基本程序设计（1）</a><time datetime="2025-02-17T07:41:33.000Z" title="发表于 2025-02-17 15:41:33">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/29/Java%E6%A6%82%E8%BF%B0/" title="Java概述"><img src="/image/top/top2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java概述"/></a><div class="content"><a class="title" href="/2025/01/29/Java%E6%A6%82%E8%BF%B0/" title="Java概述">Java概述</a><time datetime="2025-01-29T14:08:29.000Z" title="发表于 2025-01-29 22:08:29">2025-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="蓝桥杯学习笔记"><img src="/image/top/top1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝桥杯学习笔记"/></a><div class="content"><a class="title" href="/2025/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="蓝桥杯学习笔记">蓝桥杯学习笔记</a><time datetime="2025-01-27T02:43:03.000Z" title="发表于 2025-01-27 10:43:03">2025-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/top/top1.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 南星六月雪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>